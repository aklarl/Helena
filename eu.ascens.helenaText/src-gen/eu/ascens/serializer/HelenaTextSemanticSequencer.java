/*
 * generated by Xtext
 */
package eu.ascens.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import eu.ascens.helenaText.AbstractDataVariableReference;
import eu.ascens.helenaText.AbstractRoleInstanceReference;
import eu.ascens.helenaText.ActionPrefix;
import eu.ascens.helenaText.ActualDataParamsBlock;
import eu.ascens.helenaText.ActualRoleParamsBlock;
import eu.ascens.helenaText.Addition;
import eu.ascens.helenaText.AndTerm;
import eu.ascens.helenaText.BooleanValue;
import eu.ascens.helenaText.ComponentAssociationType;
import eu.ascens.helenaText.ComponentAssociationTypeReference;
import eu.ascens.helenaText.ComponentAttributeSetter;
import eu.ascens.helenaText.ComponentAttributeType;
import eu.ascens.helenaText.ComponentAttributeTypeReference;
import eu.ascens.helenaText.ComponentType;
import eu.ascens.helenaText.CreateAssignment;
import eu.ascens.helenaText.DataVariable;
import eu.ascens.helenaText.DeclaringRoleBehavior;
import eu.ascens.helenaText.EnsembleStructure;
import eu.ascens.helenaText.EqualityTerm;
import eu.ascens.helenaText.FormalDataParam;
import eu.ascens.helenaText.FormalDataParamsBlock;
import eu.ascens.helenaText.FormalRoleParam;
import eu.ascens.helenaText.FormalRoleParamsBlock;
import eu.ascens.helenaText.GetAssignment;
import eu.ascens.helenaText.GuardInParentheses;
import eu.ascens.helenaText.HelenaTextPackage;
import eu.ascens.helenaText.IfThenElse;
import eu.ascens.helenaText.IncomingMessageCall;
import eu.ascens.helenaText.InvokingRoleBehavior;
import eu.ascens.helenaText.Label;
import eu.ascens.helenaText.MessageType;
import eu.ascens.helenaText.Model;
import eu.ascens.helenaText.NondeterministicChoice;
import eu.ascens.helenaText.NotTerm;
import eu.ascens.helenaText.NumberValue;
import eu.ascens.helenaText.OperationCall;
import eu.ascens.helenaText.OperationType;
import eu.ascens.helenaText.OrTerm;
import eu.ascens.helenaText.OutgoingMessageCall;
import eu.ascens.helenaText.OwnerReference;
import eu.ascens.helenaText.PackageDeclaration;
import eu.ascens.helenaText.PlaysQuery;
import eu.ascens.helenaText.ProcessInvocation;
import eu.ascens.helenaText.QuitTerm;
import eu.ascens.helenaText.Relation;
import eu.ascens.helenaText.RoleAttributeSetter;
import eu.ascens.helenaText.RoleAttributeType;
import eu.ascens.helenaText.RoleAttributeTypeReference;
import eu.ascens.helenaText.RoleInstanceVariable;
import eu.ascens.helenaText.RoleType;
import eu.ascens.helenaText.RoleTypeWithMultiplicity;
import eu.ascens.helenaText.SelfReference;
import eu.ascens.helenaText.StringValue;
import eu.ascens.helenaText.Subtraction;
import eu.ascens.services.HelenaTextGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public class HelenaTextSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private HelenaTextGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == HelenaTextPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case HelenaTextPackage.ABSTRACT_DATA_VARIABLE_REFERENCE:
				sequence_AbstractDataVariableReference(context, (AbstractDataVariableReference) semanticObject); 
				return; 
			case HelenaTextPackage.ABSTRACT_ROLE_INSTANCE_REFERENCE:
				sequence_AbstractRoleInstanceReference(context, (AbstractRoleInstanceReference) semanticObject); 
				return; 
			case HelenaTextPackage.ACTION_PREFIX:
				sequence_ActionPrefix(context, (ActionPrefix) semanticObject); 
				return; 
			case HelenaTextPackage.ACTUAL_DATA_PARAMS_BLOCK:
				sequence_ActualDataParamsBlock(context, (ActualDataParamsBlock) semanticObject); 
				return; 
			case HelenaTextPackage.ACTUAL_ROLE_PARAMS_BLOCK:
				sequence_ActualRoleParamsBlock(context, (ActualRoleParamsBlock) semanticObject); 
				return; 
			case HelenaTextPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case HelenaTextPackage.AND_TERM:
				sequence_AndTerm(context, (AndTerm) semanticObject); 
				return; 
			case HelenaTextPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case HelenaTextPackage.COMPONENT_ASSOCIATION_TYPE:
				sequence_ComponentAssociationType(context, (ComponentAssociationType) semanticObject); 
				return; 
			case HelenaTextPackage.COMPONENT_ASSOCIATION_TYPE_REFERENCE:
				sequence_ComponentAssociationTypeReference(context, (ComponentAssociationTypeReference) semanticObject); 
				return; 
			case HelenaTextPackage.COMPONENT_ATTRIBUTE_SETTER:
				sequence_ComponentAttributeSetter(context, (ComponentAttributeSetter) semanticObject); 
				return; 
			case HelenaTextPackage.COMPONENT_ATTRIBUTE_TYPE:
				sequence_ComponentAttributeType(context, (ComponentAttributeType) semanticObject); 
				return; 
			case HelenaTextPackage.COMPONENT_ATTRIBUTE_TYPE_REFERENCE:
				sequence_ComponentAttributeTypeReference(context, (ComponentAttributeTypeReference) semanticObject); 
				return; 
			case HelenaTextPackage.COMPONENT_TYPE:
				sequence_ComponentType(context, (ComponentType) semanticObject); 
				return; 
			case HelenaTextPackage.CREATE_ASSIGNMENT:
				sequence_AbstractAssignment(context, (CreateAssignment) semanticObject); 
				return; 
			case HelenaTextPackage.DATA_VARIABLE:
				sequence_DataVariable(context, (DataVariable) semanticObject); 
				return; 
			case HelenaTextPackage.DECLARING_ROLE_BEHAVIOR:
				sequence_RoleBehavior(context, (DeclaringRoleBehavior) semanticObject); 
				return; 
			case HelenaTextPackage.ENSEMBLE_STRUCTURE:
				sequence_EnsembleStructure(context, (EnsembleStructure) semanticObject); 
				return; 
			case HelenaTextPackage.EQUALITY_TERM:
				sequence_EqualityTerm(context, (EqualityTerm) semanticObject); 
				return; 
			case HelenaTextPackage.FORMAL_DATA_PARAM:
				sequence_FormalDataParam(context, (FormalDataParam) semanticObject); 
				return; 
			case HelenaTextPackage.FORMAL_DATA_PARAMS_BLOCK:
				sequence_FormalDataParamsBlock(context, (FormalDataParamsBlock) semanticObject); 
				return; 
			case HelenaTextPackage.FORMAL_ROLE_PARAM:
				sequence_FormalRoleParam(context, (FormalRoleParam) semanticObject); 
				return; 
			case HelenaTextPackage.FORMAL_ROLE_PARAMS_BLOCK:
				sequence_FormalRoleParamsBlock(context, (FormalRoleParamsBlock) semanticObject); 
				return; 
			case HelenaTextPackage.GET_ASSIGNMENT:
				sequence_AbstractAssignment(context, (GetAssignment) semanticObject); 
				return; 
			case HelenaTextPackage.GUARD_IN_PARENTHESES:
				sequence_GuardInParentheses(context, (GuardInParentheses) semanticObject); 
				return; 
			case HelenaTextPackage.IF_THEN_ELSE:
				sequence_IfThenElse(context, (IfThenElse) semanticObject); 
				return; 
			case HelenaTextPackage.INCOMING_MESSAGE_CALL:
				sequence_IncomingMessageCall(context, (IncomingMessageCall) semanticObject); 
				return; 
			case HelenaTextPackage.INVOKING_ROLE_BEHAVIOR:
				sequence_RoleBehavior(context, (InvokingRoleBehavior) semanticObject); 
				return; 
			case HelenaTextPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case HelenaTextPackage.MESSAGE_TYPE:
				sequence_MessageType(context, (MessageType) semanticObject); 
				return; 
			case HelenaTextPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case HelenaTextPackage.NONDETERMINISTIC_CHOICE:
				sequence_NondeterministicChoice(context, (NondeterministicChoice) semanticObject); 
				return; 
			case HelenaTextPackage.NOT_TERM:
				sequence_NotTerm(context, (NotTerm) semanticObject); 
				return; 
			case HelenaTextPackage.NUMBER_VALUE:
				sequence_NumberValue(context, (NumberValue) semanticObject); 
				return; 
			case HelenaTextPackage.OPERATION_CALL:
				sequence_OperationCall(context, (OperationCall) semanticObject); 
				return; 
			case HelenaTextPackage.OPERATION_TYPE:
				sequence_OperationType(context, (OperationType) semanticObject); 
				return; 
			case HelenaTextPackage.OR_TERM:
				sequence_OrTerm(context, (OrTerm) semanticObject); 
				return; 
			case HelenaTextPackage.OUTGOING_MESSAGE_CALL:
				sequence_OutgoingMessageCall(context, (OutgoingMessageCall) semanticObject); 
				return; 
			case HelenaTextPackage.OWNER_REFERENCE:
				sequence_OwnerReference(context, (OwnerReference) semanticObject); 
				return; 
			case HelenaTextPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case HelenaTextPackage.PLAYS_QUERY:
				sequence_PlaysQuery(context, (PlaysQuery) semanticObject); 
				return; 
			case HelenaTextPackage.PROCESS:
				sequence_Process(context, (eu.ascens.helenaText.Process) semanticObject); 
				return; 
			case HelenaTextPackage.PROCESS_INVOCATION:
				sequence_ProcessInvocation(context, (ProcessInvocation) semanticObject); 
				return; 
			case HelenaTextPackage.QUIT_TERM:
				sequence_ProcessExpression(context, (QuitTerm) semanticObject); 
				return; 
			case HelenaTextPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case HelenaTextPackage.ROLE_ATTRIBUTE_SETTER:
				sequence_RoleAttributeSetter(context, (RoleAttributeSetter) semanticObject); 
				return; 
			case HelenaTextPackage.ROLE_ATTRIBUTE_TYPE:
				sequence_RoleAttributeType(context, (RoleAttributeType) semanticObject); 
				return; 
			case HelenaTextPackage.ROLE_ATTRIBUTE_TYPE_REFERENCE:
				sequence_RoleAttributeTypeReference(context, (RoleAttributeTypeReference) semanticObject); 
				return; 
			case HelenaTextPackage.ROLE_INSTANCE_VARIABLE:
				sequence_RoleInstanceVariable(context, (RoleInstanceVariable) semanticObject); 
				return; 
			case HelenaTextPackage.ROLE_TYPE:
				sequence_RoleType(context, (RoleType) semanticObject); 
				return; 
			case HelenaTextPackage.ROLE_TYPE_WITH_MULTIPLICITY:
				sequence_RoleTypeWithMultiplicity(context, (RoleTypeWithMultiplicity) semanticObject); 
				return; 
			case HelenaTextPackage.SELF_REFERENCE:
				sequence_RoleInstanceReference(context, (SelfReference) semanticObject); 
				return; 
			case HelenaTextPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case HelenaTextPackage.SUBTRACTION:
				sequence_Subtraction(context, (Subtraction) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == TypesPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if(context == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if(context == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if(context == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == XbasePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if(context == grammarAccess.getXAdditiveExpressionRule() ||
				   context == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXAndExpressionRule() ||
				   context == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXAssignmentRule() ||
				   context == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
				   context == grammarAccess.getXBlockExpressionRule() ||
				   context == grammarAccess.getXCastedExpressionRule() ||
				   context == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0() ||
				   context == grammarAccess.getXEqualityExpressionRule() ||
				   context == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXExpressionRule() ||
				   context == grammarAccess.getXExpressionOrVarDeclarationRule() ||
				   context == grammarAccess.getXMemberFeatureCallRule() ||
				   context == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0() ||
				   context == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0() ||
				   context == grammarAccess.getXMultiplicativeExpressionRule() ||
				   context == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXOrExpressionRule() ||
				   context == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXOtherOperatorExpressionRule() ||
				   context == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXParenthesizedExpressionRule() ||
				   context == grammarAccess.getXPostfixOperationRule() ||
				   context == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0() ||
				   context == grammarAccess.getXPrimaryExpressionRule() ||
				   context == grammarAccess.getXRelationalExpressionRule() ||
				   context == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
				   context == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0() ||
				   context == grammarAccess.getXUnaryOperationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if(context == grammarAccess.getXAdditiveExpressionRule() ||
				   context == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXAndExpressionRule() ||
				   context == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXAssignmentRule() ||
				   context == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
				   context == grammarAccess.getXCastedExpressionRule() ||
				   context == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0() ||
				   context == grammarAccess.getXClosureRule() ||
				   context == grammarAccess.getXEqualityExpressionRule() ||
				   context == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXExpressionRule() ||
				   context == grammarAccess.getXExpressionOrVarDeclarationRule() ||
				   context == grammarAccess.getXLiteralRule() ||
				   context == grammarAccess.getXMemberFeatureCallRule() ||
				   context == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0() ||
				   context == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0() ||
				   context == grammarAccess.getXMultiplicativeExpressionRule() ||
				   context == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXOrExpressionRule() ||
				   context == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXOtherOperatorExpressionRule() ||
				   context == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getXParenthesizedExpressionRule() ||
				   context == grammarAccess.getXPostfixOperationRule() ||
				   context == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0() ||
				   context == grammarAccess.getXPrimaryExpressionRule() ||
				   context == grammarAccess.getXRelationalExpressionRule() ||
				   context == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
				   context == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0() ||
				   context == grammarAccess.getXUnaryOperationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == XtypePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (roleInst=RoleInstanceVariable roleTypeRef=[RoleType|ID] compInstance=ComponentInstance)
	 */
	protected void sequence_AbstractAssignment(EObject context, CreateAssignment semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_INST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_INST));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_TYPE_REF));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__COMP_INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__COMP_INSTANCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAbstractAssignmentAccess().getRoleInstRoleInstanceVariableParserRuleCall_1_1_0(), semanticObject.getRoleInst());
		feeder.accept(grammarAccess.getAbstractAssignmentAccess().getRoleTypeRefRoleTypeIDTerminalRuleCall_1_5_0_1(), semanticObject.getRoleTypeRef());
		feeder.accept(grammarAccess.getAbstractAssignmentAccess().getCompInstanceComponentInstanceParserRuleCall_1_7_0(), semanticObject.getCompInstance());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (roleInst=RoleInstanceVariable roleTypeRef=[RoleType|ID] compInstance=ComponentInstance)
	 */
	protected void sequence_AbstractAssignment(EObject context, GetAssignment semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_INST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_INST));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__ROLE_TYPE_REF));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__COMP_INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ASSIGNMENT__COMP_INSTANCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAbstractAssignmentAccess().getRoleInstRoleInstanceVariableParserRuleCall_0_1_0(), semanticObject.getRoleInst());
		feeder.accept(grammarAccess.getAbstractAssignmentAccess().getRoleTypeRefRoleTypeIDTerminalRuleCall_0_5_0_1(), semanticObject.getRoleTypeRef());
		feeder.accept(grammarAccess.getAbstractAssignmentAccess().getCompInstanceComponentInstanceParserRuleCall_0_7_0(), semanticObject.getCompInstance());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ref=[AbstractDataVariable|ID]
	 */
	protected void sequence_AbstractDataVariableReference(EObject context, AbstractDataVariableReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VARIABLE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VARIABLE_REFERENCE__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAbstractDataVariableReferenceAccess().getRefAbstractDataVariableIDTerminalRuleCall_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ref=[AbstractRoleInstance|ID]
	 */
	protected void sequence_AbstractRoleInstanceReference(EObject context, AbstractRoleInstanceReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ROLE_INSTANCE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ROLE_INSTANCE_REFERENCE__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAbstractRoleInstanceReferenceAccess().getRefAbstractRoleInstanceIDTerminalRuleCall_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (action=Action processExpr=ProcessExpression)
	 */
	protected void sequence_ActionPrefix(EObject context, ActionPrefix semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ACTION_PREFIX__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ACTION_PREFIX__ACTION));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ACTION_PREFIX__PROCESS_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ACTION_PREFIX__PROCESS_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getActionPrefixAccess().getActionActionParserRuleCall_0_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getActionPrefixAccess().getProcessExprProcessExpressionParserRuleCall_2_0(), semanticObject.getProcessExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((params+=DataExpression params+=DataExpression*)?)
	 */
	protected void sequence_ActualDataParamsBlock(EObject context, ActualDataParamsBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((params+=RoleInstanceReference params+=RoleInstanceReference*)?)
	 */
	protected void sequence_ActualRoleParamsBlock(EObject context, ActualRoleParamsBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=Addition_Addition_1_0 operator='+' right=SimpleDataExpression)
	 */
	protected void sequence_Addition(EObject context, Addition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ADDITION__LEFT));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ADDITION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ADDITION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ADDITION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getOperatorPlusSignKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAdditionAccess().getRightSimpleDataExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=AndTerm_AndTerm_1_0 right=EqualityTerm)
	 */
	protected void sequence_AndTerm(EObject context, AndTerm semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.AND_TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.AND_TERM__LEFT));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.AND_TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.AND_TERM__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAndTermAccess().getAndTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndTermAccess().getRightEqualityTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=XBooleanLiteral
	 */
	protected void sequence_BooleanValue(EObject context, BooleanValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanValueAccess().getValueXBooleanLiteralParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ref=[ComponentAssociationType|ID]
	 */
	protected void sequence_ComponentAssociationTypeReference(EObject context, ComponentAssociationTypeReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.COMPONENT_ASSOCIATION_TYPE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.COMPONENT_ASSOCIATION_TYPE_REFERENCE__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComponentAssociationTypeReferenceAccess().getRefComponentAssociationTypeIDTerminalRuleCall_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=[ComponentType|ID] name=ValidID)
	 */
	protected void sequence_ComponentAssociationType(EObject context, ComponentAssociationType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_FIELD_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_FIELD_TYPE__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.COMPONENT_ASSOCIATION_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.COMPONENT_ASSOCIATION_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComponentAssociationTypeAccess().getTypeComponentTypeIDTerminalRuleCall_1_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getComponentAssociationTypeAccess().getNameValidIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (attr=ComponentAttributeTypeReference value=DataExpression)
	 */
	protected void sequence_ComponentAttributeSetter(EObject context, ComponentAttributeSetter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_SETTER__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_SETTER__ATTR));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_SETTER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_SETTER__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComponentAttributeSetterAccess().getAttrComponentAttributeTypeReferenceParserRuleCall_0_0(), semanticObject.getAttr());
		feeder.accept(grammarAccess.getComponentAttributeSetterAccess().getValueDataExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ref=[ComponentAttributeType|ID]
	 */
	protected void sequence_ComponentAttributeTypeReference(EObject context, ComponentAttributeTypeReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_TYPE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_TYPE_REFERENCE__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComponentAttributeTypeReferenceAccess().getRefComponentAttributeTypeIDTerminalRuleCall_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=JvmTypeReference name=ValidID)
	 */
	protected void sequence_ComponentAttributeType(EObject context, ComponentAttributeType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_FIELD_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_FIELD_TYPE__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.COMPONENT_ATTRIBUTE_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComponentAttributeTypeAccess().getTypeJvmTypeReferenceParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getComponentAttributeTypeAccess().getNameValidIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID (attrs+=ComponentAttributeType | assocs+=ComponentAssociationType | ops+=OperationType)*)
	 */
	protected void sequence_ComponentType(EObject context, ComponentType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ValidID
	 */
	protected void sequence_DataVariable(EObject context, DataVariable semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VARIABLE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDataVariableAccess().getNameValidIDParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID rtWithMult+=RoleTypeWithMultiplicity rtWithMult+=RoleTypeWithMultiplicity*)
	 */
	protected void sequence_EnsembleStructure(EObject context, EnsembleStructure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=EqualityTerm_EqualityTerm_1_0 operator=OpEquality right=NotTerm)
	 */
	protected void sequence_EqualityTerm(EObject context, EqualityTerm semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.EQUALITY_TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.EQUALITY_TERM__LEFT));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.EQUALITY_TERM__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.EQUALITY_TERM__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.EQUALITY_TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.EQUALITY_TERM__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEqualityTermAccess().getEqualityTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityTermAccess().getOperatorOpEqualityParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getEqualityTermAccess().getRightNotTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=JvmTypeReference name=ValidID)
	 */
	protected void sequence_FormalDataParam(EObject context, FormalDataParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VARIABLE__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.FORMAL_DATA_PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.FORMAL_DATA_PARAM__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFormalDataParamAccess().getTypeJvmTypeReferenceParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFormalDataParamAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((params+=FormalDataParam params+=FormalDataParam*)?)
	 */
	protected void sequence_FormalDataParamsBlock(EObject context, FormalDataParamsBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[RoleType|ID] name=ValidID)
	 */
	protected void sequence_FormalRoleParam(EObject context, FormalRoleParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ROLE_INSTANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ROLE_INSTANCE__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.FORMAL_ROLE_PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.FORMAL_ROLE_PARAM__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFormalRoleParamAccess().getTypeRoleTypeIDTerminalRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getFormalRoleParamAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((params+=FormalRoleParam params+=FormalRoleParam*)?)
	 */
	protected void sequence_FormalRoleParamsBlock(EObject context, FormalRoleParamsBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     guard=Guard
	 */
	protected void sequence_GuardInParentheses(EObject context, GuardInParentheses semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.GUARD_IN_PARENTHESES__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.GUARD_IN_PARENTHESES__GUARD));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGuardInParenthesesAccess().getGuardGuardParserRuleCall_1_0(), semanticObject.getGuard());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (guard=Guard ifProcessExpr=ProcessExpression elseProcessExpr=ProcessExpression)
	 */
	protected void sequence_IfThenElse(EObject context, IfThenElse semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.IF_THEN_ELSE__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.IF_THEN_ELSE__GUARD));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.IF_THEN_ELSE__IF_PROCESS_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.IF_THEN_ELSE__IF_PROCESS_EXPR));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.IF_THEN_ELSE__ELSE_PROCESS_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.IF_THEN_ELSE__ELSE_PROCESS_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIfThenElseAccess().getGuardGuardParserRuleCall_2_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getIfThenElseAccess().getIfProcessExprProcessExpressionParserRuleCall_5_0(), semanticObject.getIfProcessExpr());
		feeder.accept(grammarAccess.getIfThenElseAccess().getElseProcessExprProcessExpressionParserRuleCall_9_0(), semanticObject.getElseProcessExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (msgName=ValidID formalRoleParamsBlock=FormalRoleParamsBlock formalDataParamsBlock=FormalDataParamsBlock)
	 */
	protected void sequence_IncomingMessageCall(EObject context, IncomingMessageCall semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_MESSAGE_CALL__MSG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_MESSAGE_CALL__MSG_NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.INCOMING_MESSAGE_CALL__FORMAL_ROLE_PARAMS_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.INCOMING_MESSAGE_CALL__FORMAL_ROLE_PARAMS_BLOCK));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.INCOMING_MESSAGE_CALL__FORMAL_DATA_PARAMS_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.INCOMING_MESSAGE_CALL__FORMAL_DATA_PARAMS_BLOCK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIncomingMessageCallAccess().getMsgNameValidIDParserRuleCall_1_0(), semanticObject.getMsgName());
		feeder.accept(grammarAccess.getIncomingMessageCallAccess().getFormalRoleParamsBlockFormalRoleParamsBlockParserRuleCall_2_0(), semanticObject.getFormalRoleParamsBlock());
		feeder.accept(grammarAccess.getIncomingMessageCallAccess().getFormalDataParamsBlockFormalDataParamsBlockParserRuleCall_3_0(), semanticObject.getFormalDataParamsBlock());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ValidID
	 */
	protected void sequence_Label(EObject context, Label semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.LABEL__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLabelAccess().getNameValidIDParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (direction=MsgDirection name=ValidID formalRoleParamsBlock=FormalRoleParamsBlock formalDataParamsBlock=FormalDataParamsBlock)
	 */
	protected void sequence_MessageType(EObject context, MessageType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__DIRECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__DIRECTION));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__FORMAL_ROLE_PARAMS_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__FORMAL_ROLE_PARAMS_BLOCK));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__FORMAL_DATA_PARAMS_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.MESSAGE_TYPE__FORMAL_DATA_PARAMS_BLOCK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMessageTypeAccess().getDirectionMsgDirectionEnumRuleCall_1_0(), semanticObject.getDirection());
		feeder.accept(grammarAccess.getMessageTypeAccess().getNameValidIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMessageTypeAccess().getFormalRoleParamsBlockFormalRoleParamsBlockParserRuleCall_3_0(), semanticObject.getFormalRoleParamsBlock());
		feeder.accept(grammarAccess.getMessageTypeAccess().getFormalDataParamsBlockFormalDataParamsBlockParserRuleCall_4_0(), semanticObject.getFormalDataParamsBlock());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     headPkg=PackageDeclaration
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.MODEL__HEAD_PKG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.MODEL__HEAD_PKG));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModelAccess().getHeadPkgPackageDeclarationParserRuleCall_0(), semanticObject.getHeadPkg());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (first=ProcessExpression second=ProcessExpression)
	 */
	protected void sequence_NondeterministicChoice(EObject context, NondeterministicChoice semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.NONDETERMINISTIC_CHOICE__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.NONDETERMINISTIC_CHOICE__FIRST));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.NONDETERMINISTIC_CHOICE__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.NONDETERMINISTIC_CHOICE__SECOND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNondeterministicChoiceAccess().getFirstProcessExpressionParserRuleCall_1_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getNondeterministicChoiceAccess().getSecondProcessExpressionParserRuleCall_3_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (not='!'? atom=Atom)
	 */
	protected void sequence_NotTerm(EObject context, NotTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=XNumberLiteral
	 */
	protected void sequence_NumberValue(EObject context, NumberValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNumberValueAccess().getValueXNumberLiteralParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (variable=DataVariable? opName=ValidID actualDataParamsBlock=ActualDataParamsBlock)
	 */
	protected void sequence_OperationCall(EObject context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (returnType=JvmTypeReference name=ValidID formalDataParamsBlock=FormalDataParamsBlock)
	 */
	protected void sequence_OperationType(EObject context, OperationType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OPERATION_TYPE__RETURN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OPERATION_TYPE__RETURN_TYPE));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OPERATION_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OPERATION_TYPE__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OPERATION_TYPE__FORMAL_DATA_PARAMS_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OPERATION_TYPE__FORMAL_DATA_PARAMS_BLOCK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOperationTypeAccess().getReturnTypeJvmTypeReferenceParserRuleCall_1_0(), semanticObject.getReturnType());
		feeder.accept(grammarAccess.getOperationTypeAccess().getNameValidIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOperationTypeAccess().getFormalDataParamsBlockFormalDataParamsBlockParserRuleCall_3_0(), semanticObject.getFormalDataParamsBlock());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OrTerm_OrTerm_1_0 right=AndTerm)
	 */
	protected void sequence_OrTerm(EObject context, OrTerm semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OR_TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OR_TERM__LEFT));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OR_TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OR_TERM__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOrTermAccess().getOrTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrTermAccess().getRightAndTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (receiver=AbstractRoleInstanceReference msgName=ValidID actualRoleParamsBlock=ActualRoleParamsBlock actualDataParamsBlock=ActualDataParamsBlock)
	 */
	protected void sequence_OutgoingMessageCall(EObject context, OutgoingMessageCall semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_MESSAGE_CALL__MSG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_MESSAGE_CALL__MSG_NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OUTGOING_MESSAGE_CALL__RECEIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OUTGOING_MESSAGE_CALL__RECEIVER));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OUTGOING_MESSAGE_CALL__ACTUAL_ROLE_PARAMS_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OUTGOING_MESSAGE_CALL__ACTUAL_ROLE_PARAMS_BLOCK));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.OUTGOING_MESSAGE_CALL__ACTUAL_DATA_PARAMS_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.OUTGOING_MESSAGE_CALL__ACTUAL_DATA_PARAMS_BLOCK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOutgoingMessageCallAccess().getReceiverAbstractRoleInstanceReferenceParserRuleCall_0_0(), semanticObject.getReceiver());
		feeder.accept(grammarAccess.getOutgoingMessageCallAccess().getMsgNameValidIDParserRuleCall_2_0(), semanticObject.getMsgName());
		feeder.accept(grammarAccess.getOutgoingMessageCallAccess().getActualRoleParamsBlockActualRoleParamsBlockParserRuleCall_3_0(), semanticObject.getActualRoleParamsBlock());
		feeder.accept(grammarAccess.getOutgoingMessageCallAccess().getActualDataParamsBlockActualDataParamsBlockParserRuleCall_4_0(), semanticObject.getActualDataParamsBlock());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {OwnerReference}
	 */
	protected void sequence_OwnerReference(EObject context, OwnerReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName compTypes+=ComponentType* roleTypes+=RoleType* ensStructs+=EnsembleStructure* roleBehaviors+=RoleBehavior*)
	 */
	protected void sequence_PackageDeclaration(EObject context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (roleTypeRef=[RoleType|ID] compInstance=ComponentInstance)
	 */
	protected void sequence_PlaysQuery(EObject context, PlaysQuery semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.PLAYS_QUERY__ROLE_TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.PLAYS_QUERY__ROLE_TYPE_REF));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.PLAYS_QUERY__COMP_INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.PLAYS_QUERY__COMP_INSTANCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPlaysQueryAccess().getRoleTypeRefRoleTypeIDTerminalRuleCall_2_0_1(), semanticObject.getRoleTypeRef());
		feeder.accept(grammarAccess.getPlaysQueryAccess().getCompInstanceComponentInstanceParserRuleCall_4_0(), semanticObject.getCompInstance());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {QuitTerm}
	 */
	protected void sequence_ProcessExpression(EObject context, QuitTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     process=[Process|ID]
	 */
	protected void sequence_ProcessInvocation(EObject context, ProcessInvocation semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.PROCESS_INVOCATION__PROCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.PROCESS_INVOCATION__PROCESS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProcessInvocationAccess().getProcessProcessIDTerminalRuleCall_0_1(), semanticObject.getProcess());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID processExpr=ProcessExpression)
	 */
	protected void sequence_Process(EObject context, eu.ascens.helenaText.Process semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.PROCESS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.PROCESS__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.PROCESS__PROCESS_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.PROCESS__PROCESS_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProcessAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProcessAccess().getProcessExprProcessExpressionParserRuleCall_3_0(), semanticObject.getProcessExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=DataExpression operator=OpCompare right=DataExpression)
	 */
	protected void sequence_Relation(EObject context, Relation semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.RELATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.RELATION__LEFT));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.RELATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.RELATION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.RELATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.RELATION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRelationAccess().getLeftDataExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationAccess().getOperatorOpCompareParserRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRelationAccess().getRightDataExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (attr=RoleAttributeTypeReference value=DataExpression)
	 */
	protected void sequence_RoleAttributeSetter(EObject context, RoleAttributeSetter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_SETTER__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_SETTER__ATTR));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_SETTER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_SETTER__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRoleAttributeSetterAccess().getAttrRoleAttributeTypeReferenceParserRuleCall_0_0(), semanticObject.getAttr());
		feeder.accept(grammarAccess.getRoleAttributeSetterAccess().getValueDataExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ref=[RoleAttributeType|ID]
	 */
	protected void sequence_RoleAttributeTypeReference(EObject context, RoleAttributeTypeReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_TYPE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_TYPE_REFERENCE__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRoleAttributeTypeReferenceAccess().getRefRoleAttributeTypeIDTerminalRuleCall_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=JvmTypeReference name=ValidID)
	 */
	protected void sequence_RoleAttributeType(EObject context, RoleAttributeType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_FIELD_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_FIELD_TYPE__NAME));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_ATTRIBUTE_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRoleAttributeTypeAccess().getTypeJvmTypeReferenceParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getRoleAttributeTypeAccess().getNameValidIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (roleTypeRef=[RoleType|ID] processExpr=ProcessExpression)
	 */
	protected void sequence_RoleBehavior(EObject context, DeclaringRoleBehavior semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_BEHAVIOR__ROLE_TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_BEHAVIOR__ROLE_TYPE_REF));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.DECLARING_ROLE_BEHAVIOR__PROCESS_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.DECLARING_ROLE_BEHAVIOR__PROCESS_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRoleBehaviorAccess().getRoleTypeRefRoleTypeIDTerminalRuleCall_0_2_0_1(), semanticObject.getRoleTypeRef());
		feeder.accept(grammarAccess.getRoleBehaviorAccess().getProcessExprProcessExpressionParserRuleCall_0_4_0(), semanticObject.getProcessExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (roleTypeRef=[RoleType|ID] processInvocation=ProcessInvocation processes+=Process*)
	 */
	protected void sequence_RoleBehavior(EObject context, InvokingRoleBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {SelfReference}
	 */
	protected void sequence_RoleInstanceReference(EObject context, SelfReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ValidID
	 */
	protected void sequence_RoleInstanceVariable(EObject context, RoleInstanceVariable semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ROLE_INSTANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_ROLE_INSTANCE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRoleInstanceVariableAccess().getNameValidIDParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (roleType=[RoleType|ID] min=MultElem max=MultElem capacity=INT)
	 */
	protected void sequence_RoleTypeWithMultiplicity(EObject context, RoleTypeWithMultiplicity semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__ROLE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__ROLE_TYPE));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__MIN));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__MAX));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__CAPACITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ROLE_TYPE_WITH_MULTIPLICITY__CAPACITY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRoleTypeWithMultiplicityAccess().getRoleTypeRoleTypeIDTerminalRuleCall_1_0_1(), semanticObject.getRoleType());
		feeder.accept(grammarAccess.getRoleTypeWithMultiplicityAccess().getMinMultElemParserRuleCall_5_0(), semanticObject.getMin());
		feeder.accept(grammarAccess.getRoleTypeWithMultiplicityAccess().getMaxMultElemParserRuleCall_9_0(), semanticObject.getMax());
		feeder.accept(grammarAccess.getRoleTypeWithMultiplicityAccess().getCapacityINTTerminalRuleCall_13_0(), semanticObject.getCapacity());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID compTypes+=[ComponentType|ID] compTypes+=[ComponentType|ID]* (roleattrs+=RoleAttributeType | rolemsgs+=MessageType)*)
	 */
	protected void sequence_RoleType(EObject context, RoleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=XStringLiteral
	 */
	protected void sequence_StringValue(EObject context, StringValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.ABSTRACT_DATA_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringValueAccess().getValueXStringLiteralParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=Subtraction_Subtraction_1_0 operator='-' right=SimpleDataExpression)
	 */
	protected void sequence_Subtraction(EObject context, Subtraction semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.SUBTRACTION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.SUBTRACTION__LEFT));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.SUBTRACTION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.SUBTRACTION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, HelenaTextPackage.Literals.SUBTRACTION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HelenaTextPackage.Literals.SUBTRACTION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSubtractionAccess().getSubtractionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubtractionAccess().getOperatorHyphenMinusKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSubtractionAccess().getRightSimpleDataExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
}
